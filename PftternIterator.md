# Паттерн Iterator (итератор, cursor, курсор)
## Назначение паттерна Iterator
* Предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления.
* Абстракция в стандартных библиотеках C++ и Java, позволяющая разделить классы коллекций и алгоритмов.
* Придает обходу коллекции "объектно-ориентированный статус".
* Полиморфный обход.
## Решаемая проблема
Вам необходим механизм "абстрактного" обхода различных структур данных так, что могут определяться алгоритмы, способные взаимодействовать со структурами прозрачно.

## Обсуждение паттерна Iterator
Составной объект, такой как список, должен предоставлять способ доступа к его элементам без раскрытия своей внутренней структуры. Более того, иногда нужно перебирать элементы списка различными способами, в зависимости от конкретной задачи. Но вы, вероятно, не хотите раздувать интерфейс списка операциями для различных обходов, даже если они необходимы. Кроме того, иногда нужно иметь несколько активных обходов одного списка одновременно. Было бы хорошо иметь единый интерфейс для обхода разных типов составных объектов (т.е. полиморфная итерация).

Паттерн Iterator позволяет все это делать. Ключевая идея состоит в том, чтобы ответственность за доступ и обход переместить из составного объекта на объект Iterator, который будет определять стандартный протокол обхода.

Абстракция Iterator имеет основополагающее значение для технологии, называемой "обобщенное программирование". Эта технология четко разделяет такие понятия как "алгоритм" и "структура данных". Мотивирующие факторы: способствование компонентной разработке, повышение производительности и снижение расходов на управление.

Рассмотрим пример. Если вы хотите одновременно поддерживать четыре вида структур данных (массив, бинарное дерево, связанный список и хэш-таблица) и три алгоритма (сортировка, поиск и слияние), то традиционный подход потребует 12 вариантов конфигураций (четыре раза по три), в то время как обобщенное программирование требует лишь 7 (четыре плюс три).

## Структура паттерна Iterator
Для манипулирования коллекцией клиент использует открытый интерфейс класса Collection. Однако доступ к элементам коллекции инкапсулируется дополнительным уровнем абстракции, называемым Iterator. Каждый производный от Collection класс знает, какой производный от Iterator класс нужно создавать и возвращать. После этого клиент использует интерфейс, определенный в базовом классе Iterator.

### UML-диаграмма классов паттерна Iterator
![Image alt](http://cpp-reference.ru/images/patterns/uml-iterator.gif)
## Особенности паттерна Iterator
* Iterator может применяться для обхода сложных структур, создаваемых Composite.
* Для создания экземпляра подкласса Iterator полиморфные итераторы используют Factory Method.
* Часто Memento и Iterator используются совместно. Iterator может использовать Memento для сохранения состояния итерации и содержит его внутри себя.
## Реализация паттерна Iterator
### Реализация паттерна Iterator с использованием методов
Вынесите из коллекции функциональность "обход элементов коллекции" и придайте ей в "объектный статус". Это упростит саму коллекцию, позволит одновременно создавать множество активных обходов и отделит алгоритмы от структур данных коллекции.

Каждый контейнерный класс должен иметь итератор. Может показаться, что это является нарушением принципа инкапсуляции, так как пользователи класса Stack получают доступ к его содержимому напрямую. Однако Джон Лакош (John Lakos) приводит следующие аргументы: дизайнер класса неизбежно что-то упустит. Позже, когда пользователям потребуется дополнительная функциональность, если итератор первоначально был предусмотрен, то они смогут добавить эту функциональность в соответствии с принципом "открыт для расширения, закрыт для модификации". Без наличия итератора их единственным выходом было бы докучливое изменение рабочего кода. Ниже исходный класс Stack не содержит оператор равенства, но имеет итератор. В результате, оператор равенства может быть легко добавлен.

* Спроектируйте класс "итератор" для класса "контейнер".
* Добавьте контейнерному классу createIterator() метод.
* Клиенты запрашивают у объекта "контейнер" создание объекта-итератора.
* Клиенты используют first(), is_done(), next() и current_item() методы.
